

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Pricx">
  <meta name="keywords" content="">
  <meta name="description" content="IEEE Symposium on Security and Privacys&amp;p 22Exploit the Last Straw That Breaks Android Systems（张源）  通过深入data storing process发现针对安卓系统的新的DoS攻击，设计StrawFuzzerThe Android system services usually play a">
<meta property="og:type" content="article">
<meta property="og:title" content="20-22年安全四大关于Android的论文简要解读">
<meta property="og:url" content="http://example.com/2021/12/22/20-22%E5%B9%B4%E5%AE%89%E5%85%A8%E5%9B%9B%E5%A4%A7%E5%85%B3%E4%BA%8EAndroid%E7%9A%84%E8%AE%BA%E6%96%87%E7%AE%80%E8%A6%81%E8%A7%A3%E8%AF%BB/index.html">
<meta property="og:site_name" content="Pricx&#39;s B10g">
<meta property="og:description" content="IEEE Symposium on Security and Privacys&amp;p 22Exploit the Last Straw That Breaks Android Systems（张源）  通过深入data storing process发现针对安卓系统的新的DoS攻击，设计StrawFuzzerThe Android system services usually play a">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-22T12:00:30.000Z">
<meta property="article:modified_time" content="2021-12-22T12:21:04.982Z">
<meta property="article:author" content="Pricx">
<meta name="twitter:card" content="summary_large_image">
  
  <title>20-22年安全四大关于Android的论文简要解读 - Pricx&#39;s B10g</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":120,"cursorChar":"_","loop":true},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Pricx&#39;s B10g</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/monument.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.5)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="20-22年安全四大关于Android的论文简要解读">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-22 20:00" pubdate>
        2021年12月22日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      49k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      154 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">20-22年安全四大关于Android的论文简要解读</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年12月22日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h2 id="IEEE-Symposium-on-Security-and-Privacy"><a href="#IEEE-Symposium-on-Security-and-Privacy" class="headerlink" title="IEEE Symposium on Security and Privacy"></a><a target="_blank" rel="noopener" href="https://www.ieee-security.org/TC/SP2022/">IEEE Symposium on Security and Privacy</a></h2><h3 id="s-amp-p-22"><a href="#s-amp-p-22" class="headerlink" title="s&amp;p 22"></a>s&amp;p 22</h3><p>Exploit the Last Straw That Breaks Android Systems（张源）</p>
<blockquote>
<p>通过深入data storing process发现针对安卓系统的新的DoS攻击，设计StrawFuzzer<br>The Android system services usually play a critical role in running multiple important tasks, and delivering seamless user experiences, e.g., conveniently storing user data. In this paper, we conduct the ﬁrst systematic security study on the <strong>data storing process</strong> in Android system services, and consequently discover a novel class of design ﬂaws (named Straw), which can <strong>lead to serious DoS (Denial-of-Service) attacks</strong>, e.g., permanently crashing the whole victim Android device.<br>Then we propose a novel directed fuzzing based approach, called StrawFuzzer, to automatically vet all system services against the straw vulnerabilities. StrawFuzzer balances the tradeoff between path exploration and vulnerability exploitation. By applying StrawFuzzer on three Android systems with the latest security updates, we identiﬁed 35 unique straw vulnerabilities affecting 474 interfaces across 77 system services and successfully generated corresponding exploits, which can be used to conduct various permanent/temporary DoS attacks. We have reported our ﬁndings with suggestions for repairing the vulnerabilities to corresponding vendors. Up to now, Google has rated our vulnerability as high severity.</p>
</blockquote>
<p>Evaluating Physical-Layer BLE Location Tracking Attacks on Mobile Devices</p>
<blockquote>
<p>通过物理层缺陷形成的指纹绕过蓝牙反追踪加密进行追踪<br>Abstract—Mobile   devices   increasingly   function   as   wireless <strong>tracking  beacons</strong>.  Using  the Bluetooth  Low  Energy  (BLE)  protocol,  mobile  devices  such  as  smartphones  and smartwatches continuously  transmit  beacons  to  inform  passive  listeners  about device locations  for  applications  such  as  digital  contact  tracing for COVID-19, and even finding lost devices. These applications use  cryptographic  anonymity  that  limit  an  adversary’s ability to  use  these  beacons  to  stalk  a  user.  However,  <strong>attackers  can bypass these defenses by fingerprinting the unique physical-layer imperfections</strong> in the transmissions of specific devices.<br>We  empirically  demonstrate  that  there  are  several  key  challenges that can limit an attacker’s ability to find a stable physical layer  identifier  to  uniquely  identify  mobile devices  using  BLE, including  variations  in  the  hardware  design  of  BLE  chipsets, transmission power levels, differences in thermal conditions, and limitations  of  inexpensive radios  that  can  be  widely  deployed to  capture  raw  physical-layer  signals. <strong>We  evaluated how  much each of these factors limits accurate fingerprinting</strong> in a large-scale field  study  of hundreds  of  uncontrolled  BLE  devices,  <strong>revealing that physical-layer identification is a viable</strong>, although sometimes unreliable, way for an attacker to track mobile devices.</p>
</blockquote>
<h3 id="s-amp-p-21"><a href="#s-amp-p-21" class="headerlink" title="s&amp;p 21"></a>s&amp;p 21</h3><p>How Did That Get In My Phone? Unwanted App Distribution on Android Devices</p>
<blockquote>
<p>调查：PUP(potentially unwanted programs) apk的来源，play store占大头…<br>Android is the most popular operating system with billions of active devices. Unfortunately, its popularity and openness makes it attractive for unwanted apps, i.e., malware and <strong>potentially unwanted programs</strong> (PUP). In Android, app installations typically happen via the official and alternative markets, but also via other smaller and less understood alternative distribution vectors such as Web downloads, pay-per-install (PPI) services, backup restoration, bloatware, and IM tools. This work performs a thorough <strong>investigation on unwanted app distribution</strong> by quantifying and comparing distribution through different vectors. At the core of our <strong>measurements</strong> are reputation logs of a large security vendor, which include 7.9M apps observed in 12M devices between June and September 2019. As a first step, we measure that between 10% and 24% of users devices encounter at least one unwanted app, and compare the prevalence of malware and PUP. An analysis of the who-installs-who relationships between installers and child apps reveals that the <strong>Play market is the main app distribution vector, responsible for 87% of all installs and 67% of unwanted app installs</strong>, but it also has the best defenses against unwanted apps. Alternative markets distribute instead 5.7% of all apps, but over 10% of unwanted apps. Bloatware is also a significant unwanted app distribution vector with 6% of those installs. And, backup restoration is an unintentional distribution vector that may even allow unwanted apps to survive users’ phone replacement. We estimate unwanted app distribution via PPI to be smaller than on Windows. Finally, we observe that Web downloads are rare, but provide a riskier proposition even compared to alternative markets.</p>
</blockquote>
<p>Android Custom Permissions Demystified:From Privilege Escalation to Design Shortcomings</p>
<blockquote>
<p>关注到custom permission，这个东西可以分享资源、权限给其它应用，通过设计一吨cases挨个触发privilege escalation的fuzzer，寻找这些custom permission<br>Permission is the fundamental security mechanism for protecting user data and privacy on Android. Given its importance, security researchers have studied the design and usage of permissions from various aspects. However, most of the previous research focused on the security issues of system permissions. Overlooked by many researchers, <strong>an app can use custom permissions to share its resources and capabilities with other apps</strong>. However, the security implications of using custom permissions have not been fully understood.In this paper, we systematically evaluate the <strong>design and implementation of Android custom permissions</strong>. Notably, we built an automatic fuzzing tool, called CuPerFuzzer, to detect custom permissions related vulnerabilities existing in the Android OS. CuPerFuzzer treats the operations of the permission mechanism as a black-box and executes massive targeted test cases to <strong>trigger privilege escalation</strong>. In the experiments, CuPerFuzzer discovered 2,384 effective cases with 30 critical paths successfully. Through investigating these vulnerable cases and analyzing the source code of Android OS, we further identified a series of severe design shortcomings lying in the Android permission framework, including dangling custom permission, inconsistent permission-group mapping, custom permission elevating, and inconsistent permission definition. Exploiting any of these shortcomings, a malicious app can obtain dangeroussystem permissions without user consent and further access unauthorized platform resources. On top of these observations, we propose some general design guidelines to secure custom permissions. Our findings have been acknowledged by the Android security team and rated as High severity.</p>
</blockquote>
<p>Trust, But Verify: A Longitudinal Analysis of Android OEM Compliance and Customization</p>
<blockquote>
<p>针对OEM对AOSP的CDD（为了限制OEM的customization的条例）遵守程度展开分析，large-scale<br>Abstract—Nowadays, more than two billions of mobile devices run Android OS. At the core of this success are the open source nature of the Android Open Source Project and vendors’ ability to customize the code base and ship it on their own devices. While the possibility of customizations is beneficial to vendors, they can potentially lead to compatibility and security problems. To prevent these problems, Google developed a set of requirements that must be satisfied for a vendor to brand its devices as “Android,” and recently introduced Project Treble as an effort to partition vendor customizations. These requirements are encoded as part of a textual document (called Compatibility Definition Document, or CDD) and various automated tests. This paper performs the first longitudinal study on Android OEM customizations. We first built a dataset of 2,907 ROMs, spanning across 42 different vendors, and covering Android versions from 1.6 to 9.0 (years 2009–2020). We then developed an analysis framework and pipeline to extract each ROM’s customization layers and evaluate it across severalmetrics. For example, we analyze ROMs to determine whether they are compliant with respect to the various requirements and whether their customizations negatively affect the security posture of the overall device. In the process, we focus on various aspects, ranging from security hardening of binaries, SELinux policies, Android init scripts, and kernel security hardening techniques. Our results are worrisome.We found 579 over 2,907 (20%) of the ROMs have at least one violation for the CDD related to their Android version — incredibly, 11 of them are branded by Google itself. Some of our findings suggest that vendors often go out of theirway to bypass or “comment out” safety nets added by the Android security team. In other cases, we found ROMs that modify init scripts to launch at boot outdated versions (with known CVEs and public POCs) of programs as root and reachable from a remote attacker (e.g., tcpdump). This paper shows that Google’s efforts are not enough, and we offer several recommendations on how to improve the compliance check pipelines.</p>
</blockquote>
<p>sp’21 Trouble Over-The-Air An Analysis of FOTA Apps in the Android Ecosystem</p>
<blockquote>
<p>pre-install app<br>OEM厂商的FOTA有问题，large-scale的分析FOTA生态，发现了某些FOTAprivacy intrusive、或者存在使用开源的test key进行签名的漏洞<br>Abstract—Android firmware updates are typically managed by the so-called <strong>FOTA (Firmware Over-the-Air) apps</strong>. Such apps are highly privileged and play a critical role in maintaining devices secured and updated. The Android operating system offers standard mechanisms—available to Original Equipment Manufacturers (OEMs)—to implement their own FOTA apps but such vendor-specific implementations could be a source of security and privacy issues due to poor software engineering practices. This paper performs the first large-scale and systematic analysis of the FOTA ecosystem through a dataset of 2,013 FOTA apps detected with a tool designed for this purpose over 422,121 pre-installed apps. We classify the different stakeholders developing and deploying FOTA apps on the Android update ecosystem, showing that 43% of FOTA apps are developed by third parties. We report that some devices can have as many as 5 apps implementing FOTA capabilities. By means of static analysis of the code of FOTA apps, we show that some apps present behaviors that can be considered privacy intrusive, such as the collection of sensitive user data (e.g., geolocation linked to unique hardware identifiers), and a significant presence of third-party trackers. We also discover implementation issues leading to critical vulnerabilities, such as the use of public AOSP test keys both for signing FOTA apps and for update verification, thus allowing any update signed with the same key to be installed. Finally, we study telemetry data collected from real devices by a commercial security tool. We demonstrate that FOTA apps are responsible for the installation of non-system apps (e.g., entertainment apps and games), including malware and Potentially Unwanted Programs (PUP). Our findings suggest that FOTA development practices are misaligned with Google’s recommendations.</p>
</blockquote>
<p>sp’21 Happer Unpacking Android Apps via a Hardware-Assisted Approach（亚金）</p>
<blockquote>
<p>新型脱壳器：先观察行为再选择方法脱壳<br>Abstract—Malware authors are abusing packers (or runtimebased obfuscators) to protect malicious apps from being analyzed. Although many unpacking tools have been proposed, they can be easily impeded by the anti-analysis methods adopted by the packers, and they <strong>fail to effectively collect the hidden Dex data</strong> due to the evolving protection strategies of packers. Consequently, many packing behaviors are unknown to analysts and packed malware can circumvent the inspection. To fill the gap, in this paper, we propose a novel hardware-assisted approach that first <strong>monitors the packing behaviors</strong> and then <strong>selects the proper approach to unpack the packed apps</strong>. Moreover, we develop a prototype named Happer with a domain-specific language named behavior description language (BDL) for the ease of extending Happer after tackling several technical challenges. We conduct extensive experiments with 12 commercial Android packers and more than 24k Android apps to evaluate Happer. The results show that Happer observed 27 packing behaviors, 17 of which have not been elaborated by previous studies. Based on the observed packing behaviors, Happer adopted proper approaches to collect all the hidden Dex data and assembled them to valid Dex files.</p>
</blockquote>
<h3 id="s-amp-p-20"><a href="#s-amp-p-20" class="headerlink" title="s&amp;p 20"></a>s&amp;p 20</h3><p>An Analysis of Pre-installed Android Software</p>
<blockquote>
<p>large-scale的预装应用分析: 隐私侵犯、后门…<br>The open-source nature of the Android OS makes it possible for manufacturers to ship custom versions of the OS along with a set of pre-installed apps, often for product differentiation. Some device vendors have recently come under scrutiny for potentially invasive private data collection practices and other potentially harmful or unwanted behavior of the preinstalled apps on their devices. Yet, the landscape of preinstalled software in Android has largely remained unexplored, particularly in terms of the security and privacy implications of such customizations. In this paper, we present the first largescale study of pre-installed software on Android devices from more than 200 vendors. Our work relies on a large dataset of real-world Android firmware acquired worldwide using crowd-sourcing methods. This allows us to answer questions related to the stakeholders involved in the supply chain, from device manufacturers and mobile network operators to thirdparty organizations like advertising and tracking services, and social network platforms. Our study allows us to also uncover relationships between these actors, which seem to revolve primarily around advertising and data-driven services. Overall, the supply chain around Android’s open source model lacks transparency and has facilitated potentially harmful behaviors and backdoored access to sensitive data and services without user consent or awareness. We conclude the paper with recommendations to improve transparency, attribution, and accountability in the Android ecosystem.</p>
</blockquote>
<p><strong>TextExerciser: Feedback-driven Text Input Exercising for Android Applications</strong></p>
<blockquote>
<p>动态分析工具的辅助工具，以往安卓动态分析的障碍包括text-input区，这个东西的长度、字符要求限制了代码覆盖率，这个work就是在这方面的工作<br>Dynamic analysis of Android apps is often used together with an exerciser to increase its <strong>code coverage</strong>. One big obstacle in designing such Android app exercisers comes from the existence of text-based inputs, which are often constrained by the nature of the input field, such as the <strong>length and character restrictions</strong>.In this paper, we propose TextExerciser, an iterative, feedback-driven text input exerciser, which generates text inputs for Android apps. Our key insight is that Android apps often provide feedback, called hints, for malformed inputs so that our system can utilize such hints to improve the input generation.We implemented a prototype of TextExerciser and evaluated it by comparing TextExerciser with state-of-the-art exercisers, such as The Monkey and DroidBot. Our evaluation shows that TextExerciser can achieve significantly higher code coverage and trigger more sensitive behaviors than these tools. We also combine TextExerciser with dynamic analysis tools and show they are able to detect more privacy leaks and vulnerabilities with TextExerciser than with existing exercisers. Particularly, existing tools, under the help of TextExerciser, find several new vulnerabilities, such as one user credential leak in a popular social app with more than 10,000,000 downloads.</p>
</blockquote>
<p><strong>Ex-vivo dynamic analysis framework for Android device drivers</strong></p>
<blockquote>
<p>瞄准了一个困难点：动态分析框架如果需要设备会受性能限制，如果不需要设备就会需要复杂的硬件模拟，然而作者观察到驱动只是非常浅表地依赖硬件与内核，所以利用这点搞了个不需要porting/emulation的框架<br>The ability to execute and analyze code makes many security tasks such as exploit development, reverse engineering, and vulnerability detection much easier. However, on embedded devices such as Android smartphones, executing code in-vivo, on the device, for analysis is limited by the need to acquire such devices, the speed of the device, and in some cases the need to flash custom code onto the devices. The other option is to execute the code ex-vivo, off the device, but this approach either requires porting or complex hardware emulation. In this paper, we take advantage of the observation that many execution paths in drivers are only superficially dependent on both the hardware and kernel on which the driver executes, to create an ex-vivo dynamic driver analysis framework for Android devices that requires neither porting nor emulation. We achieve this by developing a generic evasion framework that enables driver initialization by evading hardware and kernel dependencies instead of precisely emulating them, and then developing a novel Ex-vivo AnalySIs framEwoRk (EASIER) that enables off-device analysis with the initialized driver state. Compared to on-device analysis, our approach enables the use of userspace tools and scales with the number of available commodity CPU’s, not the number of smartphones. We demonstrate the usefulness of our framework by targeting privilege escalation vulnerabilities in system call handlers in platform device drivers. We find it can load 48/62 (77%) drivers from three different Android kernels: MSM, Xiaomi, and Huawei. We then confirm that it is able to reach and detect 21 known vulnerabilities. Finally, we have discovered 12 new bugs which we have reported and confirmed.</p>
</blockquote>
<p><strong>Automatic Uncovering of Hidden Behaviors from Input Validation in Mobile Apps</strong> (林志强 暑期学校有讲座)</p>
<blockquote>
<p>观察到app内存在输入框的hidden-behavior，设计自动化工具去large-scale寻找。然后给150k应用做了测试，发现了12k有后门密码，4k有blacklist<br>Mobile applications (apps) have exploded in popularity, with billions of smartphone users using millions of apps available through markets such as the Google Play Store or the Apple App Store. While these apps have rich and useful functionality that is publicly exposed to end users, they also contain <strong>hidden behaviors</strong> that are not disclosed, such as backdoors and blacklists designed to block unwanted content. In this paper, we show that the input validation behavior-the way the mobile apps process and respond to data entered by users-can serve as a powerful tool for uncovering such hidden functionality. We therefore have developed a tool, InputScope, that automatically detects both the execution context of user input validation and also the content involved in the validation, to automatically expose the secrets of interest. We have tested InputScope with over 150,000 mobile apps, including popular apps from major app stores and preinstalled apps shipped with the phone, and found 12,706 mobile apps with backdoor secrets and 4,028 mobile apps containing blacklist secrets.</p>
</blockquote>
<p>点：应用检测到风险如何限制用户无法继续使用，比如citibank的限制可以通过简单的方法绕过</p>
<h2 id="The-ACM-Conference-on-Computer-and-Communications-Security-CCS"><a href="#The-ACM-Conference-on-Computer-and-Communications-Security-CCS" class="headerlink" title="The ACM Conference on Computer and Communications Security (CCS)"></a>The <em>ACM</em> Conference on Computer and Communications Security (<em>CCS</em>)</h2><h3 id="ccs-21"><a href="#ccs-21" class="headerlink" title="ccs 21"></a>ccs 21</h3><p>This Sneaky Piggy Went to the Android Ad Market: Misusing Mobile Sensors for Stealthy Data Exfiltration</p>
<blockquote>
<p>关注安卓传感器，提出一种基于广告生态的利用传感器的攻击，并且通过large-scale的survey发现已经有通过传感器进行access privacy的情况<br>Mobile sensors have transformed how users interact with modern smartphones and enhance their overall experience. However, the absence of sufficient access control for protecting these sensors enables a plethora of threats. As prior work has shown, malicious apps and sites can deploy a wide range of attacks that use data captured from sensors. Unfortunately, as we demonstrate, in the modern app ecosystem where most apps fetch and render third-party web content, <strong>attackers can use ads for delivering attacks</strong>.<br>In this paper, we introduce a novel attack vector that misuses the advertising ecosystem for delivering sophisticated and stealthy attacks that leverage mobile sensors. These attacks do not depend on any special app permissions or specific user actions, and affect all Android apps that contain in-app advertisements due to the improper access control of sensor data in WebView. We outline how motion sensor data can be used to infer users’ sensitive touch input (e.g., credit card information) in two distinct attack scenarios, namely intra-app and inter-app data exfiltration. While the former targets the app displaying the ad, the latter affects every other Android app running on the device. To make matters worse, we have <strong>uncovered serious flaws in Android’s app isolation, life cycle management, and access control mechanisms</strong> that enable persistent data exfiltration even after the app showing the ad is moved to the background or terminated by the user. Furthermore, as in-app ads can “piggyback” on the permissions intended for the app’s core functionality, they can also obtain information from protected sensors such as the camera, microphone and GPS. To provide a comprehensive assessment of this emerging threat, we conduct a <strong>large-scale</strong>, end-to-end, dynamic analysis of ads shown in apps available in the official Android Play Store. Our study reveals that ads in the wild are already <strong>accessing and leaking data obtained from motion sensors</strong>, thus highlighting the need for stricter access control policies and isolation mechanisms.</p>
</blockquote>
<p>Towards Transparent and Stealthy Android OS Sandboxing via Customizable Container-Based Virtualization</p>
<blockquote>
<p>container-based的虚拟化兼顾隔离与好性能，而hypervisor的在资源限制的设备上不可行，app-level的隔离不行<br>并且现有的不提供transparency or stealthiness，为了分析恶意软件必须不让其检测到在虚拟化中<br>A fast-growing demand from smartphone users is mobile virtualization.This technique supports running separate instances of virtual phone environments on the same device. In this way, users can run multiple copies of the same app simultaneously,and they can also run an untrusted app in an isolated virtual phone without causing damages to other apps. Traditional <strong>hypervisor-based virtualization is impractical to resource-constrained mobile devices</strong>. Recent app-level virtualization efforts suffer from the <strong>weak isolation mechanism</strong>. In contrast, container-based virtualization offers an isolated virtual environment with superior performance.However, existing Android containers do not meet the anti-evasion requirement for security applications: their designs are inherently incapable of providing transparency or stealthiness.<br>In this paper, we present VPBox, a novel Android OS-level sandbox framework via container-based virtualization. We integrate the principle of anti-virtual-machine detection into VPBox’s design from two aspects.First, we improve the state-of-the-art Android container work significantly for transparency.We are the first to offer complete device virtualization on mainstream Android versions.To minimize the fingerprints of VPBox’s presence, we enable all virtualization components (i.e., kernel-level device and user level device virtualization) to be executed outside of virtual phones (VPs).Second, we offer new functionality that security analysts can customize device artifacts (e.g., phone model, kernel version, and hardware profiles) without user-level hooking. This capability prevents the tested apps from detecting the particular mobile device (e.g., Google Pixel phone) that runs an Android container.Our performance evaluation on five VPs shows that VPBox runs different benchmark apps at native speed.Compared with other Android sandboxes, VPBox is the only one that can bypass a set of virtual environment detection heuristics. At last, we demonstrate VPBox’s flexibility in testing environment-sensitive malware that tries to evade sandboxes.</p>
</blockquote>
<p>Android on PC: On the Security of End-user Android Emulators</p>
<blockquote>
<p>关注到安卓虚拟机带来：通讯认证、权限管理、开放接口 三个方面的问题    ，然后survey市面上的六款虚拟器<br>Android emulators today are not only acting as a debugging tool for developers but also serving the massive end-users. These end user Android emulators have attracted millions of users due to their advantages of running mobile apps on desktops and are especially appealing for mobile game players who demand larger screens and better performance. Besides, they commonly provide some customized assistant functionalities to improve the user experience, such as keyboard mapping and app installation from the host. To implement these services, emulators inevitably <strong>introduce communication channels between host OS and Android OS</strong> (in the Virtual Machine), thus forming a unique architecture which mobile phone does not have. However, it is unknown whether this architecture brings any new security risks to emulators.<br>This paper performed a systematic study on end-user Android emulators and discovered a series of security flaws on <strong>communication channel authentication</strong>, <strong>permission control, and open interfaces</strong>. Attackers could exploit these flaws to bypass Android security mechanisms and escalate their privileges inside emulators, ultimately invading users’ privacy, such as stealing valuable game accounts and credentials. To understand the impact of our findings, we studied six popular emulators and measured their flaws. The results showed that the issues are pervasive and could cause severe security consequences. We believe our work just shows the tip of the iceberg, and further research can be done to improve the security of this ecosystem.</p>
</blockquote>
<p>Dissecting Residual APIs in Custom Android ROMs</p>
<blockquote>
<p>关注OEM厂商ROM API冗余问题，开头就指出冗余带来漏洞，large-scale，<br>怎么定位的“冗余”？<br>Many classic software vulnerabilities (e.g., Heartbleed) are <strong>rooted in unused code</strong>. In this work, we aim to understand whether unused Android functionality may similarly open unnecessary attack opportunities. Our study focuses on OEM-introduced APIs, which are added and removed erratically through different device models and releases. This instability contributes to the production of bloated custom APIs, some of which may not even be used on a particular device. We call such unused APIs Residuals.<br>In this work, we conduct the first large-scale investigation of custom Android Residuals to understand whether they may lead to access control vulnerabilities. Our investigation is driven by the intuition that it is challenging for vendor developers to ensure proper protection of Residuals. Since they are deemed unnecessary, <strong>Residuals are naturally overlooked during integration and maintenance.</strong> This is particularly exacerbated by the complexities of Android’s ever-evolving access control mechanism.<br>To facilitate the study at large, we propose a set of analysis techniques that <strong>detect and evaluate Residuals’ access control enforcement.</strong> Our techniques feature a synergy between application and framework program analysis to <strong>recognize potential Residuals in specially curated ROM samples</strong>. The Residual implementations are then statically analyzed to <strong>detect potential evolution-induced access control vulnerabilities</strong>. Our study reveals that Residuals are prevalent among OEMs. More importantly, we find that their presence may even lead to security-critical vulnerabilities.</p>
</blockquote>
<p>Ghost in the Binder: Binder Transaction Redirection Attacks in Android System Services</p>
<blockquote>
<p>#star   以前的BInder防护都只关注system作为server，作者关注到system作为aidl client的事情，然后 假设攻击者提供一个系统服务transact with a customized Binder server and then <strong>attacks from the Binder server</strong><br>system作为client我之前就知道啊<br>这个attack能达到什么效果？以前的防护是？<br>Binder, the main mechanism for Android applications to access system services, adopts a client-server role model in its design, assuming the system service as the server and the application as the client. However, a growing number of scenarios require the system service to act as a Binder client and to send queries to a Binder server possibly instantiated by the application. Departing from this role-reversal possibility, this paper proposes the Binder Transaction Redirection (BiTRe) attacks, where the attacker induces the system service to transact with a customized Binder server and then <strong>attacks from the Binder server</strong>—an often unprotected direction. We demonstrate the scale of the attack surface by enumerating the utilizable Binder interfaces in BiTRe, and discover that the attack surface grows with the Android release version. In Android 11, more than 70% of the Binder interfaces are affected by or can be utilized in BiTRe. We prove the attacks’ feasibility by (1) constructing a prototype system that can automatically generate executable programs to reach a substantial part of the attack surface, and (2) identifying a series of vulnerabilities, which are acknowledged by Google and assigned ten CVEs.</p>
</blockquote>
<p>Structural Attack against Graph Based Android Malware Detection</p>
<blockquote>
<p>对抗基于图的安卓恶意软件识别<br>large-scale，修改function call达到目的<br>还提出了between feature-space attacks and problem-space attacks<br>扰乱了分类器，但不一定能逃逸？一个是变化 一个是定向变化？？？<br>Malware detection techniques achieve great success with deeper insight into the semantics of malware. Among existing detection techniques, <strong>function call graph</strong> (FCG) based methods achieve promising performance due to their prominent representations of malware’s functionalities. Meanwhile, recent adversarial attacks <strong>not only perturb feature vectors to deceive classifiers</strong> (i.e., feature-space attacks) <strong>but also investigate how to generate real evasive malware</strong> (i.e., problem-space attacks). However, existing problem-space attacks are <strong>limited due to their inconsistent transformations</strong> between feature space and problem space. In this paper, we propose the first structural attack against graphbased Android malware detection techniques, which <strong>addresses [1] between feature-space attacks and problem-space attacks</strong>. We design a Heuristic optimization model integrated with Reinforcement learning framework to optimize our structural ATtack (HRAT). <strong>HRAT includes four types of graph modifications</strong> (i.e., inserting and deleting nodes, adding edges and rewiring) that correspond to four manipulations on apps (i.e., inserting and deleting methods, adding call relation, rewiring). Through extensive experiments on over 30k Android apps, HRAT demonstrates outstanding attack performance on both feature space (over 90% attack success rate) and problem space (up to 100% attack success rate in most cases). Besides, the experiment results show that combing multiple attack behaviors strategically makes the attack more effective and efficient.</p>
</blockquote>
<p>Understanding and Detecting Mobile Ad Fraud Through the Lens of Invalid Traffic (上交 朱浩瑾)</p>
<blockquote>
<p>Along with gaining popularity of Real-Time Bidding (RTB) based programmatic advertising, the click farm based invalid tra!c, which leverages massive real smartphones to carry out large-scale ad fraud campaigns, is becoming one of the major threats against online advertisement. In this study, we take an initial step towards the detection and large-scale measurement of the click farm based invalid traffic. Our study begins with a measurement on the device’s features using a real-world labeled dataset, which reveals a series of features distinguishing the fraudulent devices from the benign ones. Based on these features, we develop EvilHunter, a system for detecting fraudulent devices through ad bid request logs with a focus on clustering fraudulent devices. EvilHunter functions by 1) building a classi”er to distinguish fraudulent and benign devices; 2) clustering devices based on app usage patterns; and 3) relabeling devices in clusters through majority voting. EvilHunter demonstrates 97% precision and 95% recall on a real-world labeled dataset. By investigating a super click farm, we reveal several cheating strategies that are commonly adopted by fraudulent clusters. We further reduce the overhead of EvilHunter and discuss how to deploy the optimized EvilHunter in a real-world system. We are in partnership with a leading ad veri”cation company to integrate EvilHunter into their industrial platform.</p>
</blockquote>
<h3 id="ccs-20"><a href="#ccs-20" class="headerlink" title="ccs 20"></a>ccs 20</h3><p>Lies in the Air: Characterizing Fake-base-station Spam Ecosystem in China</p>
<blockquote>
<p>假基站研究任重道远，large-scale，特征化假基站，从宏观、微观两个层面看，宏观：business类型、时间模式与空间模式，微观：假基站生态怎么组织起来的、欺诈短信怎么组织并逃逸检查的<br>Fake base station (FBS) has been exploited by criminals to attack mobile users by spamming fraudulent messages for over a decade. Despite that prior work has proposed several techniques to mitigate this issue, FBS spam is still a long-standing challenging issue in some countries, such as China, and causes billions of dollars of financial loss every year. Therefore, understanding and exploring the thematic strategies in the FBS spam ecosystem at a large scale would improve the defense mechanisms. In this paper, we present the <strong>first large-scale characterization of FBS spam ecosystem</strong> by collecting three-month real-world FBS detection results. First, <strong>at “macro-level”</strong> we uncover the characteristics of FBS spammers, including their business categories, temporal patterns and spatial patterns. Second, <strong>at “micro-level”</strong>, we investigate how FBS ecosystem is organized and how fraudulent messages are constructed by campaigns to trap users and evade detection. Collectively, the results expand our understanding of the FBS spam ecosystem and provide new insights into improved mitigation mechanisms for the security community.</p>
</blockquote>
<p>PDiff: Semantic-based Patch Presence Testing for Downstream Kernels</p>
<blockquote>
<p>名字里没有安卓，实际上做的还是安卓…张源组全是这种开源软件补丁相关，包括打没打补丁 补丁打在了哪 什么的<br>Open-source kernels have been adopted by massive downstream vendors on billions of devices. However, these vendors often omit or delay the adoption of patches released in the mainstream version. Evenworse, many vendors are not publicizing the patching progress or even disclosing misleading information. However, patching status is critical for groups (e.g., governments and enterprise users) that are keen to security threats. Such a practice motivates the need for reliable patch presence testing for downstream kernels. Currently, the best means of patch presence testing is to examine the existence of a patch in the target kernel by using the code signature match. However, such an approach cannot address the key challenges in practice. Specifically, downstream vendors widely customize the mainstream code and use non-standard building configurations, which often change the code around the patching sites such that the code signatures are ineffective. In this work, we propose PDiff, a system to perform highly reliable patch presence testing with downstream kernel images. Technically speaking, PDiff generates summaries carrying the semantics related to a target patch. Based on the semantic summaries, PDiff compares the target kernel with its mainstream version before and after the adoption of the patch, preferring the closer reference version to determine the patching status. Unlike previous research on patch presence testing, our approach examines similarity based on the semantics of patches and therefore, provides high tolerance to code-level variations. Our test with 398 kernel images corresponding to 51 patches shows that PDiff can achieve high accuracy with an extremely low rate of false negatives and zero false positives. This significantly outperforms the state-of-theart tool. More importantly, PDiff demonstrates consistently high effectiveness when code customization and non-standard building configurations occur.</p>
</blockquote>
<p>Deploying Android Security Updates: an Extensive Study Involving Manufacturers, Carriers, and End Users</p>
<blockquote>
<p>ecosystem出现了…fragmented and inconsistent ecosystem<br>关注到安卓delivery of updates的问题，长时间 4年，发现了 中位24天修复，中位11天用户安装的延迟，还评估了谷歌一些项目的作用 比如Google Project Treble<br>有点像 张源的 CCS’20 PDiff，只不过这个是花的时间久，得出一个结论<br>Android’s fragmented ecosystem makes the delivery of security updates and OS upgrades cumbersome and complex. While Google initiated various projects such as Android One, Project Treble, and Project Mainline to address this problem, and other involved entities (e.g., chipset vendors, manufacturers, carriers) continuously strive to improve their processes, it is still unclear how effective these efforts are on the <strong>delivery of updates</strong> to supported end-user devices. In this paper, we perform an extensive quantitative study (Aug. 2015 to Dec. 2019) to measure the Android security updates and OS upgrades rollout process. Our study leverages multiple data sources: the Android Open Source Project (AOSP), device manufacturers, and the top four U.S. carriers (AT&amp;T, Verizon, T-Mobile, and Sprint).<br>Furthermore, we analyze an end-user dataset captured in 2019 (152M anonymized HTTP requests associated with 9.1M unique user identifiers) from a U.S.-based social network.<br>Our findings include unique measurements that, due to the <strong>fragmented and inconsistent ecosystem</strong>, were previously challenging to perform. For example, manufacturers and carriers introduce a median latency of 24 days before rolling out security updates, with an additional median delay of 11 days before end devices update(中位24天修复，中位11天用户安装的延迟？). We show that these values alter per carrier-manufacturer relationship, yet do not alter greatly based on a model’s age. Our results also delve into the effectiveness of current Android projects. For instance, security updates for Treble devices are available on average 7 days faster than for non-Treble devices. While this constitutes an improvement, the security update delay for Treble devices still averages 19 days</p>
</blockquote>
<p>Demystifying Resource Management Risks in Emerging Mobile App-in-App Ecosystems</p>
<blockquote>
<p>指出app里套app是一个流行的趋势，ecosystem，第一个系统性研究这个生态的资源管理，发现了很多缺陷，为了知道这些缺陷的影响，设计工具研究11个具备app-in-app的apps<br>App-in-app is a new and trending mobile computing paradigm in which native app-like software modules, called sub-apps, are hosted by popular mobile apps such as Wechat, Baidu, TikTok and Chrome, to enrich the host app’s functionalities and to form an “all-in-one app” ecosystem. Sub-apps access system resources through the host, and their functionalities come close to regular mobile apps (taking photos, recording voices, banking, shopping, etc.). Less clear, however, is whether the host app, typically a third-party app, is capable of securely managing sub-apps and their access to system resources. In this paper, we report the first systematic study on the resource management in app-in-app systems. Our study reveals high-impact security flaws, which allow the adversary to stealthily escalate privilege (e.g., accessing the camera, photo gallery, microphone, etc.) or acquire sensitive data (e.g., location, passwords of Amazon, Google, etc.). To understand the impacts of those flaws, we developed an analysis tool that automatically assesses 11 popular app-in-app platforms on both Android and iOS. Our results brought to light the prevalence of the security flaws. We further discuss the lessons learned and propose mitigation strategies.</p>
</blockquote>
<p>VAHunt: Warding Off New Repackaged Android Malware in App-Virtualization’s Clothing</p>
<blockquote>
<p>提出方法两步骤检测以va方式进行repkg应用进行免杀，并且large-scale测试，这个数据是安天给的…或许可以考虑和奇安信安天安恒这些合作？<br>Repackaging popular benign apps with malicious payload used to be the most common way to spread Android malware. Nevertheless, since 2016, we have observed an alarming new trend to Android ecosystem: a growing number of Android malware samples abuse recent app-virtualization innovation as a new distribution channel. App-virtualization enables a user to run multiple copies of the same app on a single device, and tens of millions of users are enjoying this convenience. However, cybercriminals repackage various malicious APK files as plugins into an app-virtualization platform, which is flexible to launch arbitrary plugins without the hassle of installation. This new style of repackaging gains the ability to bypass anti-malware scanners by hiding the grafted malicious payload in plugins, and it also defies the basic premise embodied by existing repackaged app detection solutions.<br>As app-virtualization-based apps are not necessarily malware, in this paper, we aim to make a verdict on them prior to run time. Our in-depth study results in two key observations: 1) the proxy layer between plugin apps and the Android framework is the core of app-virtualization mechanism, and it reveals the feature of finite state transitions; 2) malware typically loads plugins stealthily and hides malicious behaviors. These insights motivate us to develop a two-layer detection approach, called VAHunt. First, we design a stateful detection model to identify the existence of an app-virtualization engine in APK files. Second, we perform data flow analysis to extract fingerprinting features to differentiate between malicious and benign loading strategies. Since October 2019, we have tested VAHunt in Antiy AVL Mobile Security, a leading mobile security company, to detect more than 139K app-virtualization-based samples. Compared with the ground truth, VAHunt achieves 0.7% false negatives and zero false positive. Our automated detection frees security analysts from the burden of reverse engineering.</p>
</blockquote>
<p>Enhancing State-of-the-art Classifiers with API Semantics to Detect Evolved Android Malware（张源）</p>
<blockquote>
<p>我还是比较关注新的安卓恶意软件哪来的？<br>这个work和CCS’21那个evasion的 <em>Structural Attack against Graph Based Android Malware Detection</em> 比起来怎么样？<br>这个work做了个减缓恶意软件分类器“衰老”的 增强器<br>把进化了的恶意apps的语义相等/相同的api调用 加入到了以前最好的分类器中<br>这样就行？为什么行？怎么就naturally了….这篇文章我有大大的问号，发现了新的数据，加入到原来的或者直接继续训练模型（冻结过去的部分参数）？还是说这work想要达到的目的是在以前数据集上的表现不变，然后扩充在新数据上的表现？<br>Machine learning (ML) classifiers have been widely deployed to detect Android malware, but at the same time the application of ML classifiers also faces an emerging problem. The performance of such classifiers degrades—or called ages—significantly over time given the malware evolution(过去的分类器随时间效果降得非常快). Prior works have proposed to use retraining or active learning to reverse and improve aged models. However, the underlying classifier itself is still blind, unaware of malware evolution. Unsurprisingly, such evolution-insensitive retraining or active learning comes at a price（进行进化不敏感的refine 是因为标记巨量应用需要花费大量精力）, i.e., the labeling of tens of thousands of malware samples and the cost of significant human efforts. In this paper, we propose the first framework, called API Graph, to enhance state-of-the-art malware classifiers <strong>with the similarity information among evolved Android malware in terms of semantically-equivalent or similar API usages</strong>（回答怎么延缓“衰老”的，像是把现今的恶意apps的语义相等/相同的api调用 加入到了以前最好的分类其中）, thus naturally slowing down classifier aging. Our evaluation shows that because of the slow-down of classifier aging, APIGraph <strong>saves significant amounts of human efforts</strong> required by active learning in labeling new malware samples.</p>
</blockquote>
<h2 id="USENIX-Security-Symposium"><a href="#USENIX-Security-Symposium" class="headerlink" title="USENIX Security Symposium"></a><em>USENIX Security</em> Symposium</h2><h3 id="security-20"><a href="#security-20" class="headerlink" title="security 20"></a>security 20</h3><p>BigMAC: Fine-Grained Policy Analysis of Android Firmware</p>
<blockquote>
<p>安卓涉及许多访问控制机制，这个work关注这些机制之间的影响与交互，设计了个框架进行（对function调用）画图？<br>然后用这个框架查询：Untrust应用能影响哪些object？<br>然后说 “untrusted apps on LG being able to communicate with a kernel monitoring service”，”Samsung S8+ allowing IPC from untrusted apps to some root processes”…<br>只是算”findings”，没提到CVE<br>The Android operating system is the world’s dominant mobile computing platform. To defend against malicious applications and external attack, Android relies upon a complex combination of discretionary and mandatory access control mechanisms, including Linux capabilities, to maintain least privilege. To understand the impact and interaction between these layers, we created a framework called BIGMAC that combines and instantiates all layers of the policy together in a fine grained graph supporting millions of edges. Our model filters out paths and types not in use on actual systems that policy analysis alone would consider.<br>Unlike previous work which requires a rooted device, using only static firmware and Android domain knowledge, we are able to <strong>extract and recreate the security state of a running system</strong>, achieving a process credential recovery at best 74.7% and a filesystem DAC and MAC accuracy of over 98%. Using BIGMAC, we <strong>develop attack queries to discover sets of objects that can be influenced by untrusted applications and external peripherals</strong><br>Our evaluation against Samsung S8+ and LG G7 firmwares reveals multiple policy concerns, including untrusted apps on LG being able to communicate with a kernel monitoring service, Samsung S8+ allowing IPC from untrusted apps to some root processes, at least 24 processes with the CAP_SYS_ADMIN capability, and system_server with the capability to load kernel modules. We have reported our findings to the corresponding vendors and release BIGMAC for the community.</p>
</blockquote>
<p>FANS: Fuzzing Android Native System Services via Automated Interface Analysis（清华 张超）</p>
<blockquote>
<p>找native的漏洞很重要。。。fuzzing很流行但有挑战，<br>#star android 结合 fuzzing 狠美妙🤣，之后细看<br>前面讲挑战，后面针对挑战讲解法<br>Android native system services provide essential supports and fundamental functionalities for user apps. Finding vulnerabilities in them is crucial for Android security. Fuzzing is one of the most popular vulnerability discovery solutions, yet faces several challenges when applied to Android native system services. First, such services are invoked via a special interprocess communication (IPC) mechanism, namely binder, via service-specific interfaces. Thus, the fuzzer has to recognize all interfaces and generate interface-specific test cases automatically. Second, effective test cases should satisfy the interface model of each interface. Third, the test cases should also satisfy the semantic requirements, including variable dependencies and interface dependencies. In this paper, we propose an automated generation-based fuzzing solution FANS to find vulnerabilities in Android native system services. It first <strong>collects all interfaces in target services</strong> and <strong>uncovers deep nested multi-level interfaces to test</strong>. Then, it <strong>automatically extracts interface models</strong>, including feasible transaction code, variable names and types in the transaction data, from the abstract syntax tree (AST) of target interfaces. Further, it <strong>infers variable dependencies in transactions</strong> via the variable name and type knowledge, and <strong>infers interface dependencies</strong> via the generation and use relationship. Finally, it <strong>employs the interface models and dependency knowledge to generate sequences of transactions</strong>, which have valid formats and semantics, to test interfaces of target services. We implemented a prototype of FANS from scratch and evaluated it on six smartphones equipped with a recent version of Android, i.e., android-9.0.0_r46 , and found 30 unique vulnerabilities deduplicated from thousands of crashes, of which 20 have been confirmed by Google. Surprisingly, we also discovered 138 unique Java exceptions during fuzzing</p>
</blockquote>
<p>Towards HTTPS Everywhere on Android: We Are Not There Yet</p>
<blockquote>
<p>large-scale又出现了，谷歌出了个xml配置文件可以让app定义ta的网络安全需求？的feature，这个work就是分析这个新的feature在app上的应用情况，<br>Nowadays, virtually all mobile apps rely on communicating with a network backend. Given the sensitive nature of the data exchanged between apps and their backends, securing these network communications is of growing importance. In recent years, Google has developed a number of security mechanisms for Android apps, ranging from multiple KeyStores to the recent introduction of the new Network Security Policy, an XML-based configuration file that allows apps to define their network security posture. In this paper, we perform the first comprehensive study on these new network defense mechanisms. In particular, we present them in detail, we discuss the attacks they are defending from, and the relevant threat models. We then discuss the first large-scale analysis on this aspect. During June and July 2019, we crawled 125,419 applications and we found how only 16,332 apps adopt this new security feature. We then focus on these apps,and we uncover how developers adopt weak and potentially vulnerable network security configurations. We note that, in November 2019, Google then made the default policy stricter, which would help the adoption. We thus opted to re-crawl the same dataset (from April to June 2020) and we repeated the experiments: while more apps do adopt this new security mechanism, a significant portion of them still do not take fully advantage of it (e.g., by allowing usage of insecure protocols). We then set out to explore the root cause of these weaknesses (i.e., the why). Our analysis showed that app developers often copy-paste vulnerable policies from popular developer websites (e.g., StackOverflow). We also found that several popular ad libraries require apps to weaken their security policy, the key problem lying in the vast complexity of the ad ecosystem. As a last contribution, we propose a new extension of the Network Security Policy, so to allow app developers to embed problematic ad libraries without the need to weaken the security of their entire app.</p>
</blockquote>
<p>Cardpliance: PCI DSS Compliance of Android Applications</p>
<blockquote>
<p>又是一个针对谷歌安全策略遵守情况的分析<br>设计了个工具，然后看358个应用是否遵守<br>Smartphones and their applications have become a predominant way of computing, and it is only natural that they have become an important part of financial transaction technology. However, applications asking users to enter credit card numbers have been largely overlooked by prior studies, which frequently report pervasive security and privacy concerns in the general mobile application ecosystem. Such applications are particularly security-sensitive, and they are subject to the Payment Card Industry Data Security Standard (PCI DSS). In this paper, we <strong>design a tool called Cardpliance</strong>, which bridges the semantics of the graphical user interface with static program analysis to capture relevant requirements from PCI DSS. We use Cardpliance to study 358 popular applications from Google Play that ask the user to enter a credit card number. Overall, we found that 1.67% of the 358 applications are not compliant with PCI DSS, with vulnerabilities including improperly storing credit card numbers and card verification codes. These findings paint a largely positive picture of the state of PCI DSS compliance of popular Android applications.</p>
</blockquote>
<p>FIRMSCOPE: Automatic Uncovering of Privilege-Escalation Vulnerabilities in Pre-Installed Apps in Android Firmware</p>
<blockquote>
<p>关注pre-install app，说的有0-day？可以提权<br>发现了不能卸载的应用可能有提权漏洞， #star  设计工具（怎么设计的，可以看一下），然后发现了真实0day<br>Android devices ship with pre-installed privileged apps in their firmware — some of which are essential system components, others deliver a unique user experience — that users cannot disable（嘲讽拉满 🤣 ）. These pre-installed apps are assumed to be secure as they are handpicked or developed by the device vendors themselves rather than third parties. Unfortunately, we have identified an alarming number of Android firmware that contain privilege-escalation vulnerabilities in pre-installed apps, allowing attackers to perform unauthorized actions such as executing arbitrary commands, <strong>recording the device audio and screen, and accessing personal data to name a few.</strong>(隐私窃取就算漏洞！确信🤣) To uncover these vulnerabilities, we built FIRMSCOPE, a novel static analysis system that analyzes Android firmware to expose unwanted functionality in pre-installed apps using an efficient and practical context-sensitive, flow-sensitive, field-sensitive, and partially object-sensitive taint analysis. Our experimental results demonstrate that FIRMSCOPE significantly outperforms the state-of-the-art Android taint analysis solutions both in terms of detection power and runtime performance. We used FIRMSCOPE to scan 331,342 pre-installed apps in 2,017 Android firmware images from v4.0 to v9.0 from more than 100 Android vendors. Among them, FIRMSCOPE uncovered 850 unique privilege-escalation vulnerabilities, many of which are exploitable and 0-day.</p>
</blockquote>
<p>Automatic Hot Patch Generation for Android Kernels</p>
<blockquote>
<p>关注OEM，三方系统<br>又是关注一个谷歌修漏洞，OEM不能及时修复的问题，类似的有<br>长时间观察得出修复的时间 的 CCS’20 Deploying Android Security Updates: an Extensive Study Involving Manufacturers, Carriers, and End Users<br>对比patch列表，看看OEM到底修复没有的 CCS’20 PDiff<br>The rapid growth of the Android ecosystem has led to the fragmentation problem where a wide range of (customized) versions of Android OS exist in the market. This poses a severe security issue as it is very costly for Android vendors to fix vulnerabilities in their customized Android kernels in time. The recent development of the hot patching technique provides an ideal solution to solve this problem since it can be applied to a wide range of Android kernels without interrupting their normal functionalities. However, the current hot patches are written by human experts, which can be time consuming and error-prone. To this end, we first study the feasibility of automatic patch generation from 373 Android kernel CVEs ranging from 2012 to 2016. Then, we develop an automatic hot patch generation tool, named Vulmet, which produces semantic preserving hot patches by learning from the official patches. The key idea of Vulmet is to use the weakest precondition reasoning to transform the changes made by the official patches into the hot patch constraints. The experiments have shown that Vulmet can generate correct hot patches for 55 real-world Android kernel CVEs. The hot patches do not affect the robustness of the kernels and have low performance overhead.</p>
</blockquote>
<h3 id="security-21"><a href="#security-21" class="headerlink" title="security 21"></a>security 21</h3><p> An Investigation of the Android Kernel Patch Ecosystem</p>
<blockquote>
<p>咋又是patch，CCS’20 两篇，sec’20一篇，这又来<br>这和CCS’20 PDiff的区别是？<br>open-source projects are often reused in commercial software. Android, a popular mobile operating system, is a great example that has fostered an ecosystem of open-source kernels. However, due to the largely decentralized and fragmented nature, patch propagation from the upstream through multiple layers to end devices can be severely <strong>delayed</strong>. In this paper, we undertake a thorough investigation of the <strong>patch propagation</strong> behaviors in the entire Android kernel ecosystem. By analyzing the CVEs and patches available since the inception of the Android security bulletin, as well as open-source upstream kernels (e.g., Linux and AOSP) and hundreds of mostly binary OEM kernels (e.g., by Samsung), we find that the delays of patches are largely due to the current patching practices and the lack of knowledge about which upstream commits being security-critical. Unfortunately, we find that the gap between the first publicly available patch and its final application on end devices is often months and even years, leaving a large attack window for experienced hackers to exploit the unpatched vulnerabilities.</p>
</blockquote>
<p>Why Eve and Mallory Still Love Android: Revisiting TLS (In)Security in Android Applications</p>
<blockquote>
<p>之前有个做https的sec’20 <em>Towards HTTPS Everywhere on Android</em> 还是这个sec’20提到的配置NSC，<br>针对谷歌的这个NSC做large-scale的measurement，现在我返回看一看这和sec’20的不同？？？<br>Android applications have a long history of being vulnerable to man-in-the-middle attacks due to insecure custom TLS certificate validation implementations. To resolve this, Google deployed the Network Security Configuration (NSC), a configuration-based approach to increase custom certificate validation logic security, and implemented safeguards in Google Play to block insecure applications. In this paper, we perform a large-scale in-depth investigation of the effectiveness of these countermeasures: First, we investigate the security of 99,212 NSC settings files in 1,335,322 Google Play apps using static code and manual analysis techniques. We find that <strong>88.87% of the apps using custom NSC settings downgrade security compared to the default settings,</strong> and only 0.67% implement certificate pinning. Second, we <strong>penetrate Google Play’s protection mechanisms by trying to publish apps that are vulnerable to man-in-the-middle attacks</strong>. In contrast to official announcements by Google, we found that Play does <strong>not effectively block vulnerable apps</strong>. Finally, we performed a <strong>static code analysis study</strong> of 15,000 apps and find that 5,511 recently published apps still contain <strong>vulnerable certificate validation code</strong>. Overall, we attribute most of the problems we find to insufficient support for developers, missing clarification of security risks in official documentation, and inadequate security checks for vulnerable applications in Google Play.<br>而20年的是：<br>Nowadays, virtually all mobile apps rely on communicating with a network backend. Given the sensitive nature of the data exchanged between apps and their backends, securing these network communications is of growing importance. In recent years, Google has developed a number of security mechanisms for Android apps, ranging from multiple KeyStores to the recent introduction of the new Network Security Policy, an XML-based configuration file that allows apps to define their network security posture. In this paper, we perform the first comprehensive study on these new network defense mechanisms. In particular, we present them in detail, we discuss the attacks they are defending from, and the relevant threat models. We then discuss the first large-scale analysis on this aspect. During June and July 2019, we crawled 125,419 applications and we found how only 16,332 apps <strong>adopt this new security feature</strong>. We then focus on these apps,and we uncover how developers adopt weak and <strong>potentially vulnerable network security configurations</strong>. We note that, in November 2019, Google then made the default policy stricter, which would help the adoption. We thus opted to re-crawl the same dataset (from April to June 2020) and we repeated the experiments: while more apps do adopt this new security mechanism, a significant portion of them still <strong>do not take fully advantage of it</strong> (e.g., by allowing usage of insecure protocols). We then set out to <strong>explore the root cause</strong> of these weaknesses (i.e., the why). Our analysis showed that app developers often <strong>copy-paste vulnerable</strong> policies from popular developer websites (e.g., StackOverflow). We also found that several popular ad libraries require apps to weaken their security policy, the key problem lying in the vast complexity of the ad ecosystem. As a last contribution, <strong>we propose a new extension</strong> of the Network Security Policy, so to allow app developers to embed problematic ad libraries without the need to weaken the security of their entire app.<br>做的都是NSC但21年的更完善？？？？等会儿看看21年的有没有引用20年的这篇┗|｀O′|┛ 嗷~~</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E8%B1%A1%E8%BF%98%E5%8E%9F/">
                        <span class="hidden-mobile">《操作系统真象还原》笔记</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
